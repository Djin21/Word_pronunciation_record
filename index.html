<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
    <title>Plateforme de prononciation de mots</title>
    <style>
        /* Cleaned and compacted styling */
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body { font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; background: linear-gradient(135deg,#667eea 0%,#764ba2 100%); min-height:100vh; color:#111; }
        .container { position:absolute; top:40%; left:50%; transform:translate(-50%,-50%); max-width:900px; margin:24px auto; padding:20px; }
        .card { background: rgba(255,255,255,0.95); border-radius:16px; padding:20px; box-shadow:0 8px 30px rgba(0,0,0,0.08); }
        .header { text-align:center; margin-bottom:12px; }
        h1 { font-size:1.6rem; background:linear-gradient(135deg,#667eea,#764ba2); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
        .navigation { display:flex; justify-content:space-between; align-items:center; margin-bottom:12px; }
        .nav-btn { padding:8px 14px; border-radius:14px; border:none; cursor:pointer; background:linear-gradient(135deg,#4299e1,#667eea); color:#fff; }
        .word-display { font-size:1.8rem; font-weight:700; margin:12px 0; text-align:center; }
        .controls { display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-bottom:12px; }
        .btn { padding:10px 14px; border-radius:12px; border:none; cursor:pointer; }
        .reference-btn { background:linear-gradient(135deg,#48bb78,#38a169); color:#fff; }
        .record-btn { background:linear-gradient(135deg,#ed64a6,#d53f8c); color:#fff; }
        .record-controls { display:none; flex-direction:column; align-items:center; gap:10px; margin-top:10px; }
        .record-controls.active { display:flex; }
        .record-circle { width:72px; height:72px; border-radius:50%; border:none; cursor:pointer; font-weight:700; }
        .recordings { margin-top:14px; }
        .recording-item { display:flex; justify-content:space-between; gap:10px; align-items:center; padding:10px; border-radius:10px; background:#f7fafc; }
        .message { display:none; padding:10px; border-radius:8px; margin-top:10px; }
        .message.show { display:block; }
        .error { background:rgba(254,226,226,0.95); color:#991b1b; }
        .success { background:rgba(220,252,231,0.95); color:#065f46; }
        @media (max-width:600px) { .navigation { flex-direction:column; gap:8px; } }
    </style>
</head>
<body>
    <div class="container">
        <div class="card">
            <div class="header">
                <h1>Plateforme de prononciation de mots</h1>
                <div style="font-size:0.95rem;color:#444;">Aider nous a enrichir notre base de mots</div>
            </div>

            <div class="navigation">
                <button id="prevBtn" class="nav-btn">‚Üê Pr√©c√©dent</button>
                <div id="wordCounter">Mot 1 sur 10</div>
                <button id="nextBtn" class="nav-btn">Suivant ‚Üí</button>
            </div>

            <div class="word-display" id="wordDisplay">Chargement...</div>

            <div class="controls">
                <button id="referenceBtn" class="btn reference-btn" style="display:none">üîä Suivre la reference</button>
                <!-- <button id="importRefBtn" class="btn" style="display:none">‚¨áÔ∏è Enregistrer la ref&√©rence</button> -->
                <button id="recordRefBtn" class="btn reference-btn">üéô Enregistrer la ref√©rence</button>
                <button id="recordToggleBtn" class="btn record-btn">üé§ Enregistrer</button>
            </div>

            <div id="errorMessage" class="message error"></div>
            <div id="successMessage" class="message success"></div>

            <div id="recordingControls" class="record-controls">
                <button id="startRecordBtn" class="record-circle">‚óè REC</button>
                <div id="recordingStatus" style="display:none"> <span id="timer">0:00</span> </div>
                <button id="cancelRecordBtn" class="nav-btn">Arr√™ter</button>
            </div>

            <div id="recordingsSection" class="recordings" style="display:none">
                <h3>Vos enregistrements (<span id="recordingCount">0</span>)</h3>
                <div id="recordingsList"></div>
            </div>
        </div>
    </div>

    <script>
        // ---------- CONFIG (move secrets to backend for production) ----------
        const CLOUDINARY_CONFIG = {
            cloudName: 'dhnti4zrw',
            // For client-side uploads you must create an **unsigned** upload preset in Cloudinary
            // and put its name here. No api secret should be used in client code.
            uploadPreset: 'word_recordings'
        };

        // ---------- DATA ----------
        const words = [
  { id: 1, text: 'addaahi(machette)',    referenceAudio: null, cloudinaryRef: null }, // (machette)
  { id: 2, text: 'anngiree(engrais)',   referenceAudio: null, cloudinaryRef: null }, // (engrais)
  { id: 3, text: 'jarne(jardin)',      referenceAudio: null, cloudinaryRef: null }, // (jardin)
  { id: 4, text: 'jarnowoo(jardinier)',   referenceAudio: null, cloudinaryRef: null }, // (jardinier)
  { id: 5, text: 'asngol(vari√©t√©)',     referenceAudio: null, cloudinaryRef: null }, // (vari√©t√©)
  { id: 6, text: 'baaneewo(houe)',   referenceAudio: null, cloudinaryRef: null }, // (houe)
  { id: 7, text: 'fudgo(germe)',      referenceAudio: null, cloudinaryRef: null }, // (germe)
  { id: 8, text: 'beembal(grenier)',    referenceAudio: null, cloudinaryRef: null }, // (grenier)
  { id: 9, text: 'beendaloore(fruit)',referenceAudio: null, cloudinaryRef: null }, // (fruit)
  { id:10, text: 'koonal(fumier)',     referenceAudio: null, cloudinaryRef: null }, // (fumier)
  { id:11, text: 'bonngooru(faucille)',  referenceAudio: null, cloudinaryRef: null }, // (faucille)
  { id:12, text: 'pinndi(fleur)',     referenceAudio: null, cloudinaryRef: null }, // (fleur)
  { id:13, text: 'haako(feuillage)',      referenceAudio: null, cloudinaryRef: null }, // (feuillage)
  { id:14, text: 'hoortaago(sarcler)',  referenceAudio: null, cloudinaryRef: null }, // (sarcler)
  { id:15, text: 'saabere(champ)',    referenceAudio: null, cloudinaryRef: null }, // (champ)
  { id:16, text: 'safgo(pomper)',      referenceAudio: null, cloudinaryRef: null }, // (pomper)
  { id:17, text: 'codol(r√©colte)',      referenceAudio: null, cloudinaryRef: null }, // (r√©colte)
  { id:18, text: 'lesdi(terrain, terre, sol)',      referenceAudio: null, cloudinaryRef: null }, // (terrain, terre, sol)
  { id:19, text: 'kuwoowo(ouvrier)',    referenceAudio: null, cloudinaryRef: null }, // (ouvrier)
  { id:20, text: 'tiggugo(planter)',    referenceAudio: null, cloudinaryRef: null }  // (planter)
];

        // ---------- STATE ----------
        let currentWordIndex = 0;
        let mediaRecorder = null;
        let currentStream = null;
        let audioChunks = [];
        let isRecording = false;
        let recordingTimer = null;
        let recordingTime = 0;
        let recordings = {}; // { [wordId]: [recording, ...] }
        let isRecordingReference = false;

        // ---------- DOM ----------
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const wordDisplay = document.getElementById('wordDisplay');
        const wordCounter = document.getElementById('wordCounter');
        const referenceBtn = document.getElementById('referenceBtn');
        const importRefBtn = document.getElementById('importRefBtn');
        const recordRefBtn = document.getElementById('recordRefBtn');
        const recordToggleBtn = document.getElementById('recordToggleBtn');
        const recordingControls = document.getElementById('recordingControls');
        const startRecordBtn = document.getElementById('startRecordBtn');
        const recordingStatus = document.getElementById('recordingStatus');
        const timerEl = document.getElementById('timer');
        const cancelRecordBtn = document.getElementById('cancelRecordBtn');
        const recordingsSection = document.getElementById('recordingsSection');
        const recordingsList = document.getElementById('recordingsList');
        const recordingCount = document.getElementById('recordingCount');
        const errorMessage = document.getElementById('errorMessage');
        const successMessage = document.getElementById('successMessage');

        // ---------- UTIL ----------
        function showError(msg) { if (!errorMessage) return; errorMessage.textContent = msg; errorMessage.classList.add('show'); setTimeout(()=>errorMessage.classList.remove('show'),7000); }
        function showSuccess(msg) { if (!successMessage) return; successMessage.textContent = msg; successMessage.classList.add('show'); setTimeout(()=>successMessage.classList.remove('show'),5000); }
        function hideMessages() { if (errorMessage) errorMessage.classList.remove('show'); if (successMessage) successMessage.classList.remove('show'); }
        function formatTime(s) { const m = Math.floor(s/60); const sec = s%60; return `${m}:${sec.toString().padStart(2,'0')}`; }

        // ---------- INITIALIZATION ----------
        function init() {
            // load persisted data
            try { const w = JSON.parse(localStorage.getItem('wordsWithCloudinaryRefs')||'null'); if (Array.isArray(w)) { for (const s of w) { const obj = words.find(x=>x.text===s.text||x.id===s.id); if (obj && s.cloudinaryRef) obj.cloudinaryRef = s.cloudinaryRef; } } } catch(e){console.warn('load words',e)}
            try { const r = JSON.parse(localStorage.getItem('wordRecordings')||'null'); if (r) recordings = r; } catch(e){console.warn('load recs',e)}
            attachListeners();
            renderCurrentWord();
        }

        function attachListeners() {
            prevBtn?.addEventListener('click', ()=>{ if (currentWordIndex>0) { currentWordIndex--; renderCurrentWord(); } });
            nextBtn?.addEventListener('click', ()=>{ if (currentWordIndex<words.length-1) { currentWordIndex++; renderCurrentWord(); } });
            importRefBtn?.addEventListener('click', importReferenceIntoRecordings);
            recordRefBtn?.addEventListener('click', ()=>{ isRecordingReference = true; if (!recordingControls.classList.contains('active')) toggleRecordingControls(); });
            recordToggleBtn?.addEventListener('click', ()=>{ isRecordingReference = false; toggleRecordingControls(); });
            startRecordBtn?.addEventListener('click', handleRecording);
            cancelRecordBtn?.addEventListener('click', cancelRecording);
        }

        // ---------- RENDER ----------
        function renderCurrentWord() {
            const word = words[currentWordIndex];
            if (!word) return;
            wordDisplay.textContent = word.text;
            wordCounter.textContent = `Word ${currentWordIndex+1} of ${words.length}`;
            prevBtn.disabled = currentWordIndex===0;
            nextBtn.disabled = currentWordIndex===words.length-1;

            if (referenceBtn) referenceBtn.style.display = 'inline-block';
            if (importRefBtn) importRefBtn.style.display = (word.referenceAudio)?'inline-block':'none';

            renderRecordingsForWord();
            resetRecordingUI();
        }

        function renderRecordingsForWord(){
            const word = words[currentWordIndex];
            const list = recordings[word.id] || [];
            if (!list || list.length===0){ recordingsSection.style.display='none'; return; }
            recordingsSection.style.display='block'; recordingCount.textContent = list.length; recordingsList.innerHTML='';
            list.forEach((r,i)=>{
                const div = document.createElement('div'); div.className='recording-item';
                div.innerHTML = `<div style="font-size:14px">${r.filename}${r.isReference? ' (reference)':''} ‚Ä¢ ${r.duration || 0}s<div style="font-size:11px;color:#666">${new Date(r.uploadedAt||Date.now()).toLocaleString()}</div></div>
                <div style="display:flex;gap:8px">
                    <button class="play-btn btn" data-audio="${r.audioUrl}">‚ñ∂ Jouer</button>
                    <button class="delete-btn btn" data-wordid="${r.wordId}" data-index="${i}">üóë Supprimer</button>
                </div>`;
                recordingsList.appendChild(div);
            });
            recordingsList.querySelectorAll('.play-btn').forEach(b=>b.addEventListener('click', e=>playRecording(e.currentTarget.dataset.audio)));
            recordingsList.querySelectorAll('.delete-btn').forEach(b=>b.addEventListener('click', e=>deleteRecording(Number(e.currentTarget.dataset.wordid), Number(e.currentTarget.dataset.index))));
        }

        // ---------- IMPORT REFERENCE ----------
        async function importReferenceIntoRecordings(){
            // Instruct Cloudinary to fetch the remote file directly by sending the remote URL in the 'file' field.
            const word = words[currentWordIndex]; if (!word || !word.referenceAudio){ showError('No reference to import'); return; }
            try{
                importRefBtn.textContent='Saving...'; importRefBtn.disabled=true;
                const occurrence = (recordings[word.id]||[]).length + 1;
                const filename = `${word.text}_${occurrence}_${Date.now()}`;
                const folder = `pronunciations/${word.text}/recordings`;
                const form = new FormData();
                form.append('file', word.referenceAudio); // Cloudinary will fetch this URL
                form.append('upload_preset', CLOUDINARY_CONFIG.uploadPreset);
                form.append('resource_type', 'auto');
                form.append('folder', folder);
                form.append('public_id', filename);

                const up = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CONFIG.cloudName}/upload`,{ method:'POST', body: form });
                if (!up.ok){ const txt = await up.text().catch(()=>'[no body]'); console.error('importRef failed', up.status, up.statusText, txt); throw new Error('Import upload failed'); }
                const res = await up.json();

                const rec = { id: res.public_id, wordId: word.id, wordText: word.text, audioUrl: res.secure_url, duration:0, uploadedAt:new Date().toISOString(), cloudinaryId:res.public_id, occurrenceNumber: occurrence, filename: filename, isReference:true };
                if (!recordings[word.id]) recordings[word.id]=[];
                recordings[word.id].push(rec);
                if (!word.cloudinaryRef) { word.cloudinaryRef=res.secure_url; localStorage.setItem('wordsWithCloudinaryRefs', JSON.stringify(words)); }
                localStorage.setItem('wordRecordings', JSON.stringify(recordings));
                showSuccess('Reference saved as recording');
                renderCurrentWord();
            }catch(err){ showError('Failed to save reference as recording ‚Äî check console'); console.error('importReferenceIntoRecordings error',err); }
            finally{ importRefBtn.textContent='‚¨áÔ∏è Save Ref as Recording'; importRefBtn.disabled=false; }
        }

        // ---------- RECORDING CONTROL ----------
        function toggleRecordingControls(){
            if (!recordingControls) return;
            if (recordingControls.classList.contains('active')) { resetRecordingUI(); }
            else { recordingControls.classList.add('active'); recordToggleBtn.textContent='‚ùå Arr√™ter'; if (isRecordingReference) recordRefBtn.textContent='Recording Reference (press REC)'; }
        }

        function resetRecordingUI(){ if (!recordingControls) return; recordingControls.classList.remove('active'); recordToggleBtn.textContent='üé§ Enregistrer'; recordRefBtn.textContent='üéô Record Reference'; if (recordingStatus) recordingStatus.style.display='none'; if (startRecordBtn) { startRecordBtn.textContent='‚óè REC'; startRecordBtn.disabled=false; } recordingTime=0; if (timerEl) timerEl.textContent='0:00'; if (isRecording) stopRecording(); isRecordingReference=false; }

        async function handleRecording(){ if (!isRecording) await startRecording(); else await stopRecording(); }

        async function startRecording(){
            try{
                hideMessages();
                const stream = await navigator.mediaDevices.getUserMedia({ audio:true });
                currentStream = stream;
                // choose a mime the browser supports; we'll convert to WAV later
                let mime = 'audio/webm'; if (!MediaRecorder.isTypeSupported(mime)) mime='audio/webm;codecs=opus'; if (!MediaRecorder.isTypeSupported(mime)) mime='audio/ogg'; if (!MediaRecorder.isTypeSupported(mime)) mime='audio/wav';
                mediaRecorder = new MediaRecorder(stream, { mimeType: mime });
                audioChunks = [];
                mediaRecorder.ondataavailable = e=>{ if (e.data && e.data.size>0) audioChunks.push(e.data); };
                mediaRecorder.onstop = onRecordingStop;
                mediaRecorder.start(1000);
                isRecording=true; recordingTime=0; if (startRecordBtn) startRecordBtn.textContent='‚èπ STOP'; if (recordingStatus) recordingStatus.style.display='block'; recordingTimer = setInterval(()=>{ recordingTime++; if (timerEl) timerEl.textContent=formatTime(recordingTime); }, 1000);
            }catch(err){ showError('Could not access microphone. Ensure permission and HTTPS.'); console.error('startRecording error',err); }
        }

        async function stopRecording(){
            if (mediaRecorder && isRecording){
                try{ mediaRecorder.stop(); }catch(e){ console.warn('stop error',e); }
                if (currentStream){ try{ currentStream.getTracks().forEach(t=>t.stop()); }catch(e){} currentStream=null; }
                clearInterval(recordingTimer); isRecording=false; if (startRecordBtn){ startRecordBtn.textContent='Processing...'; startRecordBtn.disabled=true; }
            }
        }

        function cancelRecording(){ if (isRecording) stopRecording(); audioChunks=[]; resetRecordingUI(); }

        async function onRecordingStop(){
            try{
                if (!audioChunks || audioChunks.length===0){ showError('No audio captured'); resetRecordingUI(); return; }
                const rawBlob = new Blob(audioChunks, { type: audioChunks[0]?.type || 'audio/webm' });
                // convert to WAV for Cloudinary upload
                const wavBlob = await convertBlobToWav(rawBlob);
                await uploadRecording(wavBlob, isRecordingReference);
            }catch(err){ showError('Processing recorded audio failed'); console.error('onRecordingStop error', err); }
        }

        // ---------- WAV CONVERSION ----------
        // Convert any recorded blob (webm/ogg/mp3) into a WAV Blob using Web Audio API
        async function convertBlobToWav(blob){
            try{
                const arrayBuffer = await blob.arrayBuffer();
                const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                const audioBuffer = await audioCtx.decodeAudioData(arrayBuffer);
                // encode to 16-bit PCM WAV
                const wavBlob = encodeWAV(audioBuffer);
                try{ audioCtx.close(); }catch(e){}
                return wavBlob;
            }catch(err){ console.warn('convertBlobToWav failed, returning original blob', err); return blob; }
        }

        function encodeWAV(audioBuffer){
            const numChannels = audioBuffer.numberOfChannels;
            const sampleRate = audioBuffer.sampleRate;
            const format = 1; // PCM
            const bitDepth = 16;
            const samples = audioBuffer.length;
            const blockAlign = numChannels * bitDepth/8;
            const byteRate = sampleRate * blockAlign;
            const dataSize = samples * blockAlign;
            const buffer = new ArrayBuffer(44 + dataSize);
            const view = new DataView(buffer);
            let offset = 0;
            function writeString(str){ for (let i=0;i<str.length;i++){ view.setUint8(offset++, str.charCodeAt(i)); } }
            writeString('RIFF'); view.setUint32(offset, 36 + dataSize, true); offset +=4; writeString('WAVE'); writeString('fmt '); view.setUint32(offset, 16, true); offset +=4; view.setUint16(offset, format, true); offset +=2; view.setUint16(offset, numChannels, true); offset +=2; view.setUint32(offset, sampleRate, true); offset +=4; view.setUint32(offset, byteRate, true); offset +=4; view.setUint16(offset, blockAlign, true); offset +=2; view.setUint16(offset, bitDepth, true); offset +=2; writeString('data'); view.setUint32(offset, dataSize, true); offset +=4;

            // write interleaved PCM samples
            const channelData = [];
            for (let c=0;c<numChannels;c++) channelData.push(audioBuffer.getChannelData(c));
            let sampleIndex = 0;
            for (let i=0;i<samples;i++){
                for (let ch=0; ch<numChannels; ch++){
                    let sample = channelData[ch][i];
                    // clamp
                    sample = Math.max(-1, Math.min(1, sample));
                    // convert to 16-bit PCM
                    const intSample = sample < 0 ? sample * 0x8000 : sample * 0x7FFF;
                    view.setInt16(offset, intSample, true);
                    offset += 2;
                }
                sampleIndex++;
            }
            return new Blob([view], { type: 'audio/wav' });
        }

        // ---------- UPLOAD RECORDING (as WAV) ----------
        async function uploadRecording(blob, markAsReference=false){
            try{
                const word = words[currentWordIndex];
                const occurrence = (recordings[word.id]||[]).length + 1;
                const filename = `${word.text}_${occurrence}`;
                // const filename = `${word.text}_${occurrence}_${Date.now()}`;
                const folder = `word-pronunciations/${word.text}/recordings`;
                const publicId = filename;

                const form = new FormData();
                form.append('file', blob, `${filename}.wav`);
                form.append('upload_preset', CLOUDINARY_CONFIG.uploadPreset);
                form.append('resource_type', 'auto');
                form.append('folder', folder);
                form.append('public_id', publicId);

                const resp = await fetch(`https://api.cloudinary.com/v1_1/${CLOUDINARY_CONFIG.cloudName}/upload`,{ method:'POST', body: form });
                if (!resp.ok){ const txt = await resp.text().catch(()=>'[no body]'); console.error('uploadRecording failed', resp.status, resp.statusText, txt); throw new Error('Upload failed'); }
                const res = await resp.json();

                const rec = { id:res.public_id, wordId: word.id, wordText: word.text, audioUrl: res.secure_url, duration: recordingTime, uploadedAt:new Date().toISOString(), cloudinaryId:res.public_id, occurrenceNumber: occurrence, filename: filename, isReference: !!markAsReference };
                if (!recordings[word.id]) recordings[word.id]=[];
                recordings[word.id].push(rec);
                if (markAsReference){ word.cloudinaryRef = res.secure_url; localStorage.setItem('wordsWithCloudinaryRefs', JSON.stringify(words)); }
                localStorage.setItem('wordRecordings', JSON.stringify(recordings));
                showSuccess('Recording uploaded successfully (WAV)');
                renderCurrentWord();
            }catch(err){ showError('Failed to upload recording ‚Äî see console'); console.error('uploadRecording error', err); }
            finally{ resetRecordingUI(); audioChunks=[]; if (startRecordBtn) startRecordBtn.disabled=false; isRecordingReference=false; }
        }

        // ---------- PLAY / DELETE ----------
        function playRecording(url){ if (!url){ showError('No audio to play'); return; } if (window.currentAudio){ window.currentAudio.pause(); window.currentAudio.currentTime=0; } window.currentAudio = new Audio(url); window.currentAudio.play().catch(e=>{ showError('Playback error'); console.error(e); }); }

        async function deleteRecording(wordId, idx){ if (!confirm('Delete this recording locally? Cloud deletion requires a server-side call with your API secret.')) return; try{ if (recordings && recordings[wordId]){ recordings[wordId].splice(idx,1); localStorage.setItem('wordRecordings', JSON.stringify(recordings)); } await renumberRecordings(wordId); showSuccess('Recording removed locally.'); renderCurrentWord(); }catch(err){ showError('Failed to delete recording'); console.error('deleteRecording error', err); } }

        async function renumberRecordings(wordId){ const arr = recordings[wordId]; if (!arr) return; const w = words.find(x=>x.id===Number(wordId)); if (!w) return; for (let i=0;i<arr.length;i++){ arr[i].occurrenceNumber = i+1; arr[i].filename = `${w.text}_${i+1}`; } localStorage.setItem('wordRecordings', JSON.stringify(recordings)); }

        // ---------- START ----------
        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
